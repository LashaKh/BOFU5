import { saveAs } from 'file-saver';
import { ExportStrategy, ExportOptions, ExportResult, ExportFormat } from '../index';
import { Editor } from '@tiptap/react';
import { Document, Packer, Paragraph, TextRun, AlignmentType } from 'docx';

export class SimpleDocxExportStrategy extends ExportStrategy {
  getSupportedFormats(): ExportFormat[] {
    return ['docx'];
  }

  async export(content: any, options: ExportOptions): Promise<ExportResult> {
    try {
      let htmlContent: string;
      let articleTitle = 'Untitled Article';

      // Handle different content types
      if (typeof content === 'string') {
        htmlContent = content;
      } else if (content?.editor && content.editor instanceof Editor) {
        htmlContent = content.editor.getHTML();
        articleTitle = content.title || articleTitle;
      } else if (content?.html) {
        htmlContent = content.html;
        articleTitle = content.title || articleTitle;
      } else if (content?.json) {
        const tempEditor = new Editor({
          content: content.json,
          editable: false,
        });
        htmlContent = tempEditor.getHTML();
        tempEditor.destroy();
        articleTitle = content.title || articleTitle;
      } else {
        throw new Error('Unsupported content format for DOCX export');
      }

      // Create DOCX document
      const docxBlob = await this.createSimpleDocxFromHtml(htmlContent, articleTitle, options);

      const filename = this.generateFilename(
        articleTitle, 
        'docx', 
        options.customFilename
      );

      // Trigger download
      saveAs(docxBlob, filename);

      return {
        success: true,
        filename,
        blob: docxBlob,
        metadata: this.createMetadata('docx', '', content.articleId, articleTitle),
      };
    } catch (error) {
      console.error('DOCX export failed:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown DOCX export error',
      };
    }
  }

  private async createSimpleDocxFromHtml(
    htmlContent: string, 
    title: string, 
    options: ExportOptions
  ): Promise<Blob> {
    // Parse HTML to extract text content
    const parser = new DOMParser();
    const doc = parser.parseFromString(htmlContent, 'text/html');
    
    // Create document sections
    const sections: Paragraph[] = [];
    
    // Add title
    sections.push(
      new Paragraph({
        children: [
          new TextRun({
            text: title,
            bold: true,
            size: 32, // 16pt in half-points
          }),
        ],
        alignment: AlignmentType.CENTER,
        spacing: {
          after: 400, // 20pt spacing after
        },
      })
    );

    // Add metadata if requested
    if (options.includeMetadata) {
      const now = new Date();
      sections.push(
        new Paragraph({
          children: [
            new TextRun({
              text: `Exported: ${now.toLocaleDateString()} ${now.toLocaleTimeString()}`,
              size: 18, // 9pt
              color: '666666',
            }),
          ],
          alignment: AlignmentType.CENTER,
          spacing: {
            after: 800, // Extra spacing before content
          },
        })
      );
    }

    // Process HTML elements to plain text
    const textContent = this.extractTextFromHtml(doc.body);
    const paragraphs = textContent.split('\n').filter(p => p.trim());
    
    paragraphs.forEach(paragraphText => {
      if (paragraphText.trim()) {
        sections.push(
          new Paragraph({
            children: [
              new TextRun({
                text: paragraphText.trim(),
                size: 24, // 12pt
              }),
            ],
            spacing: {
              after: 200,
            },
          })
        );
      }
    });

    // Add footer
    sections.push(
      new Paragraph({
        children: [
          new TextRun({
            text: `Generated by BOFU Article Editor on ${new Date().toLocaleDateString()}`,
            size: 16, // 8pt
            color: '999999',
          }),
        ],
        alignment: AlignmentType.CENTER,
        spacing: {
          before: 800,
        },
      })
    );

    // Create document
    const document = new Document({
      creator: 'BOFU Article Editor',
      title,
      description: `Exported article: ${title}`,
      sections: [
        {
          properties: {},
          children: sections,
        },
      ],
    });

    // Generate and return blob
    const buffer = await Packer.toBlob(document);
    return buffer;
  }

  private extractTextFromHtml(element: Element): string {
    let text = '';
    
    for (const node of Array.from(element.childNodes)) {
      if (node.nodeType === Node.TEXT_NODE) {
        text += node.textContent || '';
      } else if (node.nodeType === Node.ELEMENT_NODE) {
        const el = node as Element;
        
        // Add line breaks for block elements
        if (['p', 'div', 'br', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'li'].includes(el.tagName.toLowerCase())) {
          text += '\n';
        }
        
        // Recursively extract text from child elements
        text += this.extractTextFromHtml(el);
        
        // Add line breaks after block elements
        if (['p', 'div', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'li'].includes(el.tagName.toLowerCase())) {
          text += '\n';
        }
      }
    }
    
    return text;
  }
} 